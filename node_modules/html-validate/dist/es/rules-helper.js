import { t as isTextNode, u as isElementNode, a as ConfigError, D as DynamicValue, w as generateIdSelector } from './core.js';

const patternCache = new Map();
function compileStringPattern(pattern) {
    const regexp = pattern.replace(/[*]+/g, ".+");
    /* eslint-disable-next-line security/detect-non-literal-regexp */
    return new RegExp(`^${regexp}$`);
}
function compileRegExpPattern(pattern) {
    /* eslint-disable-next-line security/detect-non-literal-regexp */
    return new RegExp(`^${pattern}$`);
}
function compilePattern(pattern) {
    const cached = patternCache.get(pattern);
    if (cached) {
        return cached;
    }
    const match = pattern.match(/^\/(.*)\/$/);
    const regexp = match ? compileRegExpPattern(match[1]) : compileStringPattern(pattern);
    patternCache.set(pattern, regexp);
    return regexp;
}
/**
 * @public
 */
function keywordPatternMatcher(list, keyword) {
    for (const pattern of list) {
        const regexp = compilePattern(pattern);
        if (regexp.test(keyword)) {
            return true;
        }
    }
    return false;
}
/**
 * @internal
 */
function isKeywordIgnored(options, keyword, matcher = (list, it) => list.includes(it)) {
    const { include, exclude } = options;
    /* ignore keyword if not present in "include" */
    if (include && !matcher(include, keyword)) {
        return true;
    }
    /* ignore keyword if present in "excludes" */
    if (exclude && matcher(exclude, keyword)) {
        return true;
    }
    return false;
}

const ARIA_HIDDEN_CACHE = Symbol(isAriaHidden.name);
const HTML_HIDDEN_CACHE = Symbol(isHTMLHidden.name);
const ROLE_PRESENTATION_CACHE = Symbol(isPresentation.name);
/**
 * Tests if this element is present in the accessibility tree.
 *
 * In practice it tests whenever the element or its parents has
 * `role="presentation"` or `aria-hidden="false"`. Dynamic values counts as
 * visible since the element might be in the visibility tree sometimes.
 */
function inAccessibilityTree(node) {
    return !isAriaHidden(node) && !isPresentation(node);
}
function isAriaHiddenImpl(node) {
    const isHidden = (node) => {
        const ariaHidden = node.getAttribute("aria-hidden");
        return Boolean(ariaHidden && ariaHidden.value === "true");
    };
    return {
        byParent: node.parent ? isAriaHidden(node.parent) : false,
        bySelf: isHidden(node),
    };
}
function isAriaHidden(node, details) {
    const cached = node.cacheGet(ARIA_HIDDEN_CACHE);
    if (cached) {
        return details ? cached : cached.byParent || cached.bySelf;
    }
    const result = node.cacheSet(ARIA_HIDDEN_CACHE, isAriaHiddenImpl(node));
    return details ? result : result.byParent || result.bySelf;
}
function isHTMLHiddenImpl(node) {
    const isHidden = (node) => {
        const hidden = node.getAttribute("hidden");
        return hidden !== null && hidden.isStatic;
    };
    return {
        byParent: node.parent ? isHTMLHidden(node.parent) : false,
        bySelf: isHidden(node),
    };
}
function isHTMLHidden(node, details) {
    const cached = node.cacheGet(HTML_HIDDEN_CACHE);
    if (cached) {
        return details ? cached : cached.byParent || cached.bySelf;
    }
    const result = node.cacheSet(HTML_HIDDEN_CACHE, isHTMLHiddenImpl(node));
    return details ? result : result.byParent || result.bySelf;
}
/**
 * Tests if this element or a parent element has role="presentation".
 *
 * Dynamic values yields `false` just as if the attribute wasn't present.
 */
function isPresentation(node) {
    if (node.cacheExists(ROLE_PRESENTATION_CACHE)) {
        return Boolean(node.cacheGet(ROLE_PRESENTATION_CACHE));
    }
    let cur = node;
    do {
        const role = cur.getAttribute("role");
        /* role="presentation" */
        if (role && role.value === "presentation") {
            return cur.cacheSet(ROLE_PRESENTATION_CACHE, true);
        }
        /* sanity check: break if no parent is present, normally not an issue as the
         * root element should be found first */
        if (!cur.parent) {
            break;
        }
        /* check parents */
        cur = cur.parent;
    } while (!cur.isRootElement());
    return node.cacheSet(ROLE_PRESENTATION_CACHE, false);
}

const cachePrefix = classifyNodeText.name;
const HTML_CACHE_KEY = Symbol(`${cachePrefix}|html`);
const A11Y_CACHE_KEY = Symbol(`${cachePrefix}|a11y`);
const IGNORE_HIDDEN_ROOT_HTML_CACHE_KEY = Symbol(`${cachePrefix}|html|ignore-hidden-root`);
const IGNORE_HIDDEN_ROOT_A11Y_CACHE_KEY = Symbol(`${cachePrefix}|a11y|ignore-hidden-root`);
/**
 * @public
 */
var TextClassification;
(function (TextClassification) {
    TextClassification[TextClassification["EMPTY_TEXT"] = 0] = "EMPTY_TEXT";
    TextClassification[TextClassification["DYNAMIC_TEXT"] = 1] = "DYNAMIC_TEXT";
    TextClassification[TextClassification["STATIC_TEXT"] = 2] = "STATIC_TEXT";
})(TextClassification || (TextClassification = {}));
/**
 * @internal
 */
function getCachekey(options) {
    const { accessible = false, ignoreHiddenRoot = false } = options;
    if (accessible && ignoreHiddenRoot) {
        return IGNORE_HIDDEN_ROOT_A11Y_CACHE_KEY;
    }
    else if (ignoreHiddenRoot) {
        return IGNORE_HIDDEN_ROOT_HTML_CACHE_KEY;
    }
    else if (accessible) {
        return A11Y_CACHE_KEY;
    }
    else {
        return HTML_CACHE_KEY;
    }
}
/* While I cannot find a reference about this in the standard the <select>
 * element kinda acts as if there is no text content, most particularly it
 * doesn't receive and accessible name. The `.textContent` property does
 * however include the <option> childrens text. But for the sake of the
 * validator it is probably best if the classification acts as if there is no
 * text as I think that is what is expected of the return values. Might have
 * to revisit this at some point or if someone could clarify what section of
 * the standard deals with this. */
function isSpecialEmpty(node) {
    return node.is("select") || node.is("textarea");
}
/**
 * Checks text content of an element.
 *
 * Any text is considered including text from descendant elements. Whitespace is
 * ignored.
 *
 * If any text is dynamic `TextClassification.DYNAMIC_TEXT` is returned.
 *
 * @public
 */
function classifyNodeText(node, options = {}) {
    const { accessible = false, ignoreHiddenRoot = false } = options;
    const cacheKey = getCachekey(options);
    if (node.cacheExists(cacheKey)) {
        return node.cacheGet(cacheKey);
    }
    if (!ignoreHiddenRoot && isHTMLHidden(node)) {
        return node.cacheSet(cacheKey, TextClassification.EMPTY_TEXT);
    }
    if (!ignoreHiddenRoot && accessible && isAriaHidden(node)) {
        return node.cacheSet(cacheKey, TextClassification.EMPTY_TEXT);
    }
    if (isSpecialEmpty(node)) {
        return node.cacheSet(cacheKey, TextClassification.EMPTY_TEXT);
    }
    const text = findTextNodes(node, {
        ...options,
        ignoreHiddenRoot: false,
    });
    /* if any text is dynamic classify as dynamic */
    if (text.some((cur) => cur.isDynamic)) {
        return node.cacheSet(cacheKey, TextClassification.DYNAMIC_TEXT);
    }
    /* if any text has non-whitespace character classify as static */
    if (text.some((cur) => cur.textContent.match(/\S/) !== null)) {
        return node.cacheSet(cacheKey, TextClassification.STATIC_TEXT);
    }
    /* default to empty */
    return node.cacheSet(cacheKey, TextClassification.EMPTY_TEXT);
}
function findTextNodes(node, options) {
    const { accessible = false } = options;
    let text = [];
    for (const child of node.childNodes) {
        if (isTextNode(child)) {
            text.push(child);
        }
        else if (isElementNode(child)) {
            if (isHTMLHidden(child, true).bySelf) {
                continue;
            }
            if (accessible && isAriaHidden(child, true).bySelf) {
                continue;
            }
            text = text.concat(findTextNodes(child, options));
        }
    }
    return text;
}

function hasAltText(image) {
    const alt = image.getAttribute("alt");
    /* missing or boolean */
    if (alt === null || alt.value === null) {
        return false;
    }
    return alt.isDynamic || alt.value.toString() !== "";
}

function hasAriaLabel(node) {
    const label = node.getAttribute("aria-label");
    /* missing or boolean */
    if (label === null || label.value === null) {
        return false;
    }
    return label.isDynamic || label.value.toString() !== "";
}

/**
 * Joins a list of words into natural language.
 *
 * - `["foo"]` becomes `"foo"`
 * - `["foo", "bar"]` becomes `"foo or bar"`
 * - `["foo", "bar", "baz"]` becomes `"foo, bar or baz"`
 * - and so on...
 *
 * @internal
 * @param values - List of words to join
 * @param conjunction - Conjunction for the last element.
 * @returns String with the words naturally joined with a conjunction.
 */
function naturalJoin(values, conjunction = "or") {
    switch (values.length) {
        case 0:
            return "";
        case 1:
            return values[0];
        case 2:
            return `${values[0]} ${conjunction} ${values[1]}`;
        default:
            return `${values.slice(0, -1).join(", ")} ${conjunction} ${values.slice(-1)[0]}`;
    }
}

/**
 * Partition an array to two new lists based on the result of a
 * predicate. Similar to `Array.filter` but returns both matching and
 * non-matching in the same call.
 *
 * Elements matching the predicate is placed in the first array and elements not
 * matching is placed in the second.
 *
 * @public
 * @param values - The array of values to partition.
 * @param predicate - A predicate function taking a single element and returning
 * a boolean.
 * @returns - Two arrays where the first contains all elements where the
 * predicate matched and second contains the rest of the elements.
 */
function partition(values, predicate) {
    const initial = [[], []];
    return values.reduce((accumulator, value, index) => {
        const match = predicate(value, index, values);
        accumulator[match ? 0 : 1].push(value);
        return accumulator;
    }, initial);
}

/**
 * Represents casing for a name, e.g. lowercase, uppercase, etc.
 */
class CaseStyle {
    /**
     * @param style - Name of a valid case style.
     */
    constructor(style, ruleId) {
        if (!Array.isArray(style)) {
            style = [style];
        }
        if (style.length === 0) {
            throw new ConfigError(`Missing style for ${ruleId} rule`);
        }
        this.styles = this.parseStyle(style, ruleId);
    }
    /**
     * Test if a text matches this case style.
     */
    match(text) {
        return this.styles.some((style) => text.match(style.pattern));
    }
    get name() {
        const names = this.styles.map((style) => style.name);
        switch (this.styles.length) {
            case 1:
                return names[0];
            case 2:
                return names.join(" or ");
            default: {
                const last = names.slice(-1);
                const rest = names.slice(0, -1);
                return `${rest.join(", ")} or ${last[0]}`;
            }
        }
    }
    parseStyle(style, ruleId) {
        return style.map((cur) => {
            switch (cur.toLowerCase()) {
                case "lowercase":
                    return { pattern: /^[a-z]*$/, name: "lowercase" };
                case "uppercase":
                    return { pattern: /^[A-Z]*$/, name: "uppercase" };
                case "pascalcase":
                    return { pattern: /^[A-Z][A-Za-z]*$/, name: "PascalCase" };
                case "camelcase":
                    return { pattern: /^[a-z][A-Za-z]*$/, name: "camelCase" };
                default:
                    throw new ConfigError(`Invalid style "${cur}" for ${ruleId} rule`);
            }
        });
    }
}

const HAS_ACCESSIBLE_TEXT_CACHE = Symbol(hasAccessibleName.name);
function isHidden(node, context) {
    const { reference } = context;
    if (reference && reference.isSameNode(node)) {
        return false;
    }
    else {
        return isHTMLHidden(node) || !inAccessibilityTree(node);
    }
}
function hasImgAltText(node, context) {
    if (node.is("img")) {
        return hasAltText(node);
    }
    else if (node.is("svg")) {
        return node.textContent.trim() !== "";
    }
    else {
        for (const img of node.querySelectorAll("img, svg")) {
            const hasName = hasAccessibleNameImpl(img, context);
            if (hasName) {
                return true;
            }
        }
        return false;
    }
}
function hasLabel(node) {
    var _a;
    const value = (_a = node.getAttributeValue("aria-label")) !== null && _a !== void 0 ? _a : "";
    return Boolean(value.trim());
}
function isLabelledby(node, context) {
    const { document, reference } = context;
    /* if we already have resolved one level of reference we don't resolve another
     * level (as per accname step 2B) */
    if (reference) {
        return false;
    }
    const ariaLabelledby = node.ariaLabelledby;
    /* consider dynamic aria-labelledby as having a name as we cannot resolve it
     * so no way to prove correctness */
    if (ariaLabelledby instanceof DynamicValue) {
        return true;
    }
    /* ignore elements without aria-labelledby */
    if (ariaLabelledby === null) {
        return false;
    }
    return ariaLabelledby.some((id) => {
        const selector = generateIdSelector(id);
        return document.querySelectorAll(selector).some((child) => {
            return hasAccessibleNameImpl(child, {
                document,
                reference: child,
            });
        });
    });
}
/**
 * This algorithm is based on ["Accessible Name and Description Computation
 * 1.2"][accname] with some exceptions:
 *
 * It doesn't compute the actual name but only the presence of one, e.g. if a
 * non-empty flat string is present the algorithm terminates with a positive
 * result.
 *
 * It takes some optimization shortcuts such as starting with step F as it
 * would be more common usage and as there is no actual name being computed
 * the order wont matter.
 *
 * [accname]: https://w3c.github.io/accname
 */
function hasAccessibleNameImpl(current, context) {
    const { reference } = context;
    /* if this element is hidden (see function for exceptions) it does not have an accessible name */
    if (isHidden(current, context)) {
        return false;
    }
    /* special case: when this element is directly referenced by aria-labelledby
     * we ignore `hidden` */
    const ignoreHiddenRoot = Boolean(reference && reference.isSameNode(current));
    const text = classifyNodeText(current, { accessible: true, ignoreHiddenRoot });
    if (text !== TextClassification.EMPTY_TEXT) {
        return true;
    }
    if (hasImgAltText(current, context)) {
        return true;
    }
    if (hasLabel(current)) {
        return true;
    }
    if (isLabelledby(current, context)) {
        return true;
    }
    return false;
}
/**
 * Returns `true` if the element has an accessible name.
 *
 * It does not yet consider if the elements role prohibits naming, e.g. a `<p>`
 * element will still show up as having an accessible name.
 *
 * @public
 * @param document - Document element.
 * @param current - The element to get accessible name for
 * @returns `true` if the element has an accessible name.
 */
function hasAccessibleName(document, current) {
    /* istanbul ignore next: we're not testing cache */
    if (current.cacheExists(HAS_ACCESSIBLE_TEXT_CACHE)) {
        return Boolean(current.cacheGet(HAS_ACCESSIBLE_TEXT_CACHE));
    }
    const result = hasAccessibleNameImpl(current, {
        document,
        reference: null,
    });
    return current.cacheSet(HAS_ACCESSIBLE_TEXT_CACHE, result);
}

export { CaseStyle as C, TextClassification as T, isHTMLHidden as a, isAriaHidden as b, classifyNodeText as c, hasAccessibleName as d, inAccessibilityTree as e, hasAriaLabel as f, hasAltText as h, isKeywordIgnored as i, keywordPatternMatcher as k, naturalJoin as n, partition as p };
//# sourceMappingURL=rules-helper.js.map
