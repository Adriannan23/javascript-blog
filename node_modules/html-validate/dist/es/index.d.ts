import { z as Report, c as ConfigLoader, H as HtmlValidate, a as ConfigData } from './core.js';
export { e as Attribute, A as AttributeData, ab as AttributeEvent, g as CSSStyleDeclaration, ar as CompatibilityOptions, ad as ConditionalEvent, C as Config, b as ConfigError, a2 as ConfigReadyEvent, ag as DOMLoadEvent, ah as DOMReadyEvent, I as DeferredMessage, ae as DirectiveEvent, af as DoctypeEvent, D as DynamicValue, aa as ElementReadyEvent, a1 as Event, a0 as EventCallback, E as EventDump, $ as EventHandler, an as FileSystemConfigLoader, ao as Formatter, f as HtmlElement, am as ListenEventMap, L as Location, F as Message, m as MetaAttribute, n as MetaAttributeAllowedCallback, q as MetaCopyableProperty, M as MetaData, k as MetaDataTable, l as MetaElement, o as MetaTable, j as NestedError, N as NodeClosed, aj as ParseBeginEvent, ak as ParseEndEvent, Z as Parser, Q as Plugin, P as ProcessAttributeCallback, w as ProcessElementCallback, x as ProcessElementContext, B as Reporter, G as Result, R as Rule, r as RuleConstructor, s as RuleDocumentation, ai as RuleErrorEvent, i as SchemaValidationError, X as SchemaValidationPatch, S as Severity, t as Source, u as SourceHooks, a3 as SourceReadyEvent, d as StaticConfigLoader, a8 as TagCloseEvent, a7 as TagEndEvent, a6 as TagOpenEvent, a9 as TagReadyEvent, a5 as TagStartEvent, O as TemplateExtractor, T as TextNode, h as TokenDump, a4 as TokenEvent, J as TransformContext, K as Transformer, al as TriggerEventMap, U as UserError, V as Validator, ac as WhitespaceEvent, W as WrappedError, aq as compatibilityCheck, p as configPresets, Y as definePlugin, ap as formatterFactory, _ as ruleExists, y as sliceLocation, v as version } from './core.js';
export { d as defineMetadata, m as metadataHelper } from './meta-helper.js';
export { I as IncludeExcludeOptions, T as TextClassification, c as classifyNodeText, k as keywordPatternMatcher } from './rules-helper.js';
export { SchemaObject } from 'ajv';

interface ExpandOptions {
    /**
     * Working directory. Defaults to `process.cwd()`.
     */
    cwd?: string;
    /**
     * List of extensions to search for when expanding directories. Extensions
     * should be passed without leading dot, e.g. "html" instead of ".html".
     */
    extensions?: string[];
}

interface InitResult {
    filename: string;
}

interface CLIOptions {
    configFile?: string;
    rules?: string | string[];
}
/**
 * @public
 */
declare class CLI {
    private options;
    private config;
    private loader;
    private ignored;
    /**
     * Create new CLI helper.
     *
     * Can be used to create tooling with similar properties to bundled CLI
     * script.
     */
    constructor(options?: CLIOptions);
    /**
     * Returns list of files matching patterns and are not ignored. Filenames will
     * have absolute paths.
     *
     * @public
     */
    expandFiles(patterns: string[], options?: ExpandOptions): string[];
    getFormatter(formatters: string): (report: Report) => string;
    /**
     * Initialize project with a new configuration.
     *
     * A new `.htmlvalidate.json` file will be placed in the path provided by
     * `cwd`.
     */
    init(cwd: string): Promise<InitResult>;
    /**
     * Searches ".htmlvalidateignore" files from filesystem and returns `true` if
     * one of them contains a pattern matching given filename.
     */
    isIgnored(filename: string): boolean;
    /**
     * Clear cache.
     *
     * Previously fetched [[HtmlValidate]] instances must either be fetched again
     * or call [[HtmlValidate.flushConfigCache]].
     */
    clearCache(): void;
    /**
     * Get HtmlValidate instance with configuration based on options passed to the
     * constructor.
     *
     * @internal
     */
    getLoader(): ConfigLoader;
    /**
     * Get HtmlValidate instance with configuration based on options passed to the
     * constructor.
     *
     * @public
     */
    getValidator(): HtmlValidate;
    /**
     * @internal
     */
    getConfig(): ConfigData;
}

export { CLI, ConfigData, ConfigLoader, HtmlValidate, Report };
